from contextlib import contextmanager
from contextlib import nullcontext as nullcontext
from contextlib import suppress as suppress
from datetime import timedelta
from typing import Any, Callable, Iterator, Optional, Tuple, Type, Union

from funcy.decorators import Call, decorator

collecting: Any
once: Any

class ErrorRateExceeded(Exception): ...

def fallback(*approaches): ...
def ignore(
    errors: Union[Type[Exception], Tuple[Type[Exception], ...]],
    default: Optional[Any] = ...,
) -> Callable: ...
@decorator
def joining(call, sep): ...
def limit_error_rate(
    fails: int, timeout: int, exception: Type[Exception] = ...
) -> Callable: ...
def once_per(*argnames) -> Callable: ...
def once_per_args(func: Callable) -> Callable: ...
@decorator
def post_processing(call: Call, func: Callable): ...
def raiser(
    exception_or_class: Union[str, Exception, Type[Exception]] = ..., *args, **kwargs
) -> Callable: ...
@contextmanager
def reraise(
    errors: Union[Type[Exception], Tuple[Type[Exception], ...]], into: Callable
) -> Iterator[None]: ...
@decorator
def retry(
    call: Call,
    tries: int,
    errors: Union[Type[Exception], Tuple[Type[Exception], ...]] = ...,
    timeout: Union[int, Callable] = ...,
    filter_errors: Optional[Callable] = ...,
) -> Any: ...
def silent(func: Callable) -> Callable: ...
def throttle(period: Union[int, timedelta]) -> Callable: ...
@decorator
def wrap_with(call, ctx): ...
